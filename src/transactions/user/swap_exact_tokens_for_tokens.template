import Token1Name from Token1Addr

import FungibleToken from "../../contracts/tokens/FungibleToken.cdc"
import SwapRouter from "../../contracts/SwapRouter.cdc"

transaction(
    tokenKeyPath: [String],
    exactAmountIn: UFix64,
    amountOutMin: UFix64,
    deadline: UFix64,

    tokenInVaultPath: StoragePath,
    tokenOutVaultPath: StoragePath,
    tokenOutReceiverPath: PublicPath,
    tokenOutBalancePath: PublicPath,
) {
    prepare(userAccount: AuthAccount) {
        
        var len = tokenKeyPath.length
        let tokenInKey = tokenKeyPath[0]
        let tokenOutKey = tokenKeyPath[len-1]

        var tokenOutAmountTotal = 0.0

        var tokenOutReceiverRef = userAccount.borrow<&FungibleToken.Vault>(from: tokenOutVaultPath)
        if tokenOutReceiverRef == nil {
            userAccount.save(<- Token1Name.createEmptyVault(), to: tokenOutVaultPath)
            userAccount.link<&Token1Name.Vault{FungibleToken.Receiver}>(tokenOutReceiverPath, target: tokenOutVaultPath)
            userAccount.link<&Token1Name.Vault{FungibleToken.Balance}>(tokenOutBalancePath, target: tokenOutVaultPath)

            tokenOutReceiverRef = userAccount.borrow<&FungibleToken.Vault>(from: tokenOutVaultPath)
        }

        let exactVaultIn <- userAccount.borrow<&FungibleToken.Vault>(from: tokenInVaultPath)!.withdraw(amount: exactAmountIn)

        let vaultOut <- SwapRouter.swapExactTokensForTokens(
            exactVaultIn: <-exactVaultIn,
            amountOutMin: amountOutMin,
            tokenKeyPath: tokenKeyPath,
            deadline: deadline
        )

        log("out ".concat(vaultOut.balance.toString()))
        tokenOutReceiverRef!.deposit(from: <-vaultOut)
    }
}