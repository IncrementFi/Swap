import Token1Name from Token1Addr

import FungibleToken from "../../contracts/tokens/FungibleToken.cdc"
import SwapFactory from "../../contracts/SwapFactory.cdc"
import SwapInterfaces from "../../contracts/SwapInterfaces.cdc"
import SwapConfig from "../../contracts/SwapConfig.cdc"
import SwapRouter from "../../contracts/SwapRouter.cdc"



// deploy code copied by a deployed contract
transaction(
    tokenInAmounts: [UFix64],
    paths: [String],

    tokenInVaultPath: StoragePath,

    tokenOutVaultPath: StoragePath,
    tokenOutReceiverPath: PublicPath,
    tokenOutBalancePath: PublicPath,
) {
    prepare(userAccount: AuthAccount) {
        let tokenInKey = paths[0]
        /*
        let tokenInVault <- userAccount.borrow<&FungibleToken.Vault>(from: tokenInVaultPath)!.withdraw(amount: tokenInAmount)

        let tokenOutVault <- SwapRouter.swap(vaultIn: <- tokenInVault, tokenKeyPath: tokenKeyPath)
        
        let tokenOutAmount = tokenOutVault.balance

        
        var tokenOutReceiverRef = userAccount.borrow<&FungibleToken.Vault>(from: tokenOutVaultPath)
        if tokenOutReceiverRef == nil {
            //userAccount.save(<- Token1Name.createEmptyVault(), to: tokenOutVaultPath)
            //userAccount.link<&Token1Name.Vault{FungibleToken.Receiver}>(tokenOutReceiverPath, target: tokenOutVaultPath)
            //userAccount.link<&Token1Name.Vault{FungibleToken.Balance}>(tokenOutBalancePath, target: tokenOutVaultPath)

            tokenOutReceiverRef = userAccount.borrow<&FungibleToken.Vault>(from: tokenOutVaultPath)
        }

        tokenOutReceiverRef!.deposit(from: <- tokenOutVault)

        let tokenInKey = tokenKeyPath[0]
        let tokenOutKey = tokenKeyPath[tokenKeyPath.length-1]
        
        log("=====> swap path from ".concat(tokenInKey).concat(" to ").concat(tokenOutKey).concat(" at ").concat(tokenInAmount.toString()).concat(" to ").concat(tokenOutAmount.toString()))
         */
    }
}